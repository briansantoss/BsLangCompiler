import argparse
import subprocess
from pathlib import Path
import bs_core
from bs_lexer import lexer

def file_exists(filepath) -> bool:
    return filepath.exists() and filepath.is_file()
    
def turn_to_python(line_toks, out_filepath):
    python_prog = [
        "# This code was automatically generated by the BsLang compiler (aka bsc)\n",
        "# Please DO NOT modify unless you know and comprehend how it was made\n",
        "\n"
    ]

    for instruction, args_list in line_toks:
        # O método join só tem efeito visível para listas com mais de um elemento, então não são necessárias validações condicionais
        python_cmd = f"{bs_core.instruction_map[instruction]}({", ".join(args_list)})\n"
        python_prog.append(python_cmd)

    if file_exists(out_filepath):
        answer = input("A file with this name and at this path already exists. " 
                       "Would you like to overwrite? (y/n): ")
        
        if answer.casefold() != "y":
            print("Ok. No file generated")
            exit(0)
    
    with open(out_filepath, "w", encoding="utf-8") as out_file:
        out_file.writelines(python_prog)


def main():
    parser = argparse.ArgumentParser(description="BSLang Compiler manual") 

    subparsers = parser.add_subparsers(dest="subcommand")

    # Adiciona o subcomando 'compile'
    parser_compile = subparsers.add_parser("compile", help="Take a bs source code and compile it.")
    parser_compile.add_argument("file", help="A file path")
    parser_compile.add_argument("--o", help="Output file name", required=False)

    parser_compile_run = subparsers.add_parser("compile-run", help="Take a bs source code, compile and run it.")
    parser_compile_run.add_argument("file", help="A file path")
    parser_compile_run.add_argument("--o", help="Output file name", required=False)

    prog_args = parser.parse_args()

    if not prog_args.subcommand:
        parser.print_help()
        exit(0)

    # Montando o caminho completo para o arquivo passado
    filepath = Path(prog_args.file).resolve() 
    if not file_exists(filepath):
        print(f"Error: No file named found '{filepath.name}' at the given path")
        exit(1)
    
    out_filepath = Path((prog_args.o if prog_args.o else filepath.stem ) + bs_core.OUT_FILE_EXTENSION).resolve()
    # Salvando os tokens do programa
    prog_toks = lexer(filepath) 

    turn_to_python(prog_toks, out_filepath)

    if prog_args.subcommand == "compile-run":
        subprocess.run(["py", out_filepath])


if __name__ == "__main__":
    main()